#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on Mon May 2 09:30:21 2016
Utility to generate an annotated PDF from a MIT record

Usage: ./mit2pdf [options]

@author: Ángel Piñeiro Souto
"""

from StringIO import StringIO
from optparse import OptionParser
from matplotlib.backends.backend_pdf import PdfPages
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import numpy as np
import subprocess
import shlex
import os, sys


def rdsamp(record):
    """
    Reads data from a MIT record, using rdsamp
    """
    args = shlex.split("rdsamp -r "+record+" -c")
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    data = np.genfromtxt(StringIO(out), delimiter=",", usecols=(1, 2))
    return data

def rdann(record,annotator="atr"):
    """
    Reads annotations from a MIT record, using rdann
    """
    args = shlex.split("rdann -r "+record+" -a "+annotator)
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    annotations = [line.split() for line in StringIO(out)]
    return annotations

def wfdbdesc(record):
    """
    Get info from a MIT record, using wfdbdesc
    """
    args = shlex.split("wfdbdesc "+record)
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    info = {'channels':[]}

    for l in StringIO(out):
        if "Sampling frequency" in l:
            freq = (l.split(":")[1]).replace("Hz","")
            info['freq'] = int(freq)
        elif "Description" in l:
            chan = {'description': (l.split(":")[1]).strip()}
        elif "Gain" in l:
            chan['gain'] = int((l.split(" ")[2]).strip())
            info['channels'].append(chan)
    return info

def plotEcgPage(recordData, annotations, header, filter, samples, offset=0, pdf=None):
    """
    Plot a page of signal with annotations
    """
    pad = 2
    data = []
    for i in xrange(offset, offset + samples):
        data.extend(recordData[i])

    if len(data):
        dataMin = min(data);
        dataMax = max(data);
        yAxInit = dataMin - (dataMax - dataMin) / 5
        yAxEnd = dataMax + (dataMax - dataMin) / 5
        for i in range(channels):
            if pdf is not None:
                fig = plt.gcf()
                fig.set_size_inches(24+2*pad, 4 * channels)
            sp = plt.subplot(channels, 1, i + 1)
            sp.get_yaxis().set_visible(True)
            sp.get_xaxis().set_visible(False)
            sp.set_xlim(axInit, axEnd)
            sp.set_ylim(yAxInit, yAxEnd)
            sp.axis('off')
            if showGrid:
                plotGrid(dataMax,dataMin)
            sp.plot(data[i::channels], linewidth=0.8)
            plotAnnotations(annotations,header,filter,offset, i, data)

        plt.tight_layout(pad=pad)
        # show plot
        if pdf is not None:
            fromStr =  str(timedelta(seconds=int(offset/header['freq'])))
            toStr = str(timedelta(seconds=int((offset + len(data) / channels)/header['freq'])))
            plt.suptitle('Record '+ recordName +' - ' + fromStr + " to " + toStr + "  [ 1 square = 0.04sec/0.1mV ]")
            fig.savefig(pdf, format='pdf', dpi=600)
            plt.close()
        else:
            plt.show()


def plotAnnotations(annotations, header,filter, offset, channel, data):
    """
    Plot beat marks
    """
    minSample = offset
    maxSample = offset + len(data) / channels
    top = max(data)
    bottom = min(data)
    plt.text(1, top-(top-bottom)/2, header['channels'][channel]['description'], color='green',fontsize=11)
    for a in annotations:
        sampleNumber = int(a[1])
        cls = str(a[2])
        if (not filter or cls in filter) and sampleNumber > minSample:
            if sampleNumber < maxSample:
                plt.axvline(x=sampleNumber - offset, color='black',  lw=0.9, alpha=0.9)
                plt.text(sampleNumber - offset, top, " " + cls, color='black',fontsize=11)
                if showSamples:
                    plt.text(sampleNumber - offset + 5, bottom, str(sampleNumber), color='grey',fontsize=8)
            else:
                break

def plotGrid(top, bottom):
    """
    Plot grid
    """
    pageWidthInSeconds = (pageSize/freq)
    numberOfLines = pageWidthInSeconds*25
    for i in xrange(1,numberOfLines+1):
        pos = i*pageSize/numberOfLines
        plt.axvline(x=pos, color='red', lw=0.1, alpha=.3 if i%5==0 else 0.1)

    for i in xrange(int(bottom)-1,int(top+1)):
        for j in xrange(10):
            plt.axhline(y=i+float(j)/10, color='red', lw=0.1, alpha=.3 if j == 0 or j==5 else 0.1)

"""
Main program
"""
parser = OptionParser()
parser.add_option("-r", "--record", dest="record", default="", help="Record to print")
parser.add_option("-a", "--annotator", dest="annotator", default="atr", help="Annotator")
parser.add_option("-o", "--offset", dest="offset", default="0", help="Offset to start printing in seconds or as an absolute instant in the format hh:mm:ss (default=0)")
parser.add_option("-l", "--limit", dest="limit", default="", help="Limit to print in seconds or as an absolute instant in the format hh:mm:ss (default=None)")
parser.add_option("-p", "--pageSize", dest="pageSize", default=10, help="Number of seconds per page (default=10)")
parser.add_option("-f", "--filter", dest="filter", default="", help="Filter beat classes shown Ex:N,V")
parser.add_option("-d", "--destination", dest="output", default="ecg.pdf", help="Output file")
parser.add_option("--showSamples", action="store_true", dest="showSamples", help="Show sample numbers")
parser.add_option("--showGrid", action="store_true", dest="showGrid", help="Show grid")

(options, args) = parser.parse_args()
filter= options.filter.split(",") if options.filter else []
showSamples = options.showSamples
showGrid = options.showGrid

# get record path from options
record = options.record

if not record:
    parser.print_help()
    sys.exit(1)

recordName = os.path.basename(record)
# read header info
header = wfdbdesc(record)

if not 'freq' in header.keys():
    print "Unable to find header file for record '" + recordName + "'"
    sys.exit(1)

# number of channels in the input file
channels = len(header["channels"])
freq = header["freq"]


# get record samples
# print "Record info: ", header
print "Loading data and annotations for record " + recordName + "..."

data = rdsamp(record)
gain = header["channels"][0]["gain"]
data = data / gain
totalSamples = len(data)
samplesPerLead = totalSamples

if ":" in options.offset:
    t = datetime.strptime(options.offset,"%H:%M:%S")
    secs = timedelta(hours=t.hour, minutes=t.minute, seconds=t.second).total_seconds()
    offset = int(secs*freq)
else:
    offset=int(options.offset)*freq

if not options.limit:
    limit = totalSamples - offset
elif ":" in options.limit:
    t = datetime.strptime(options.limit,"%H:%M:%S")
    secs = timedelta(hours=t.hour, minutes=t.minute, seconds=t.second).total_seconds()
    limit = int(secs*freq-offset)
else:
    limit=int(options.limit) - offset *freq


samples = min(samplesPerLead, offset + limit) if limit > 0 else samplesPerLead
pageSize = int(options.pageSize)*freq

start = offset
axEnd = pageSize
axInit = 0


annotations = rdann(record,options.annotator)
pages = limit / pageSize + 1

print totalSamples, offset, limit, pageSize

print "Read " + str(len(data)) + " samples"
print "Read " + str(len(annotations)) + " annotations"
print "\nResulting PDF will have " + str(pages) + " pages"

pdf = PdfPages(options.output)
# iterate and print pages
currentPage = 1
while start < samples:
    if start + pageSize > samples:
        pageSize = samples - start
    print "Printing page " + str(currentPage) + " of " + str(pages) + "..."
    plotEcgPage(data, annotations, header, filter, pageSize,start, pdf)
    start = start + pageSize
    currentPage+=1
pdf.close()

print "Done. Check " + options.output
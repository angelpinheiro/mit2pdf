#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on Mon May 2 09:30:21 2016
Utility to generate an annotated PDF from a MIT record

Usage: ./mit2pdf [options]

@author: Ángel Piñeiro Souto
"""

from StringIO import StringIO
from optparse import OptionParser
from matplotlib.backends.backend_pdf import PdfPages
from datetime import datetime, timedelta
import time
import matplotlib.pyplot as plt
import numpy as np
import subprocess
import shlex
import json
import os, sys


def rdsamp(record):
    """
    Reads data from a MIT record, using rdsamp
    """
    args = shlex.split("rdsamp -r "+record+" -c")
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    data = np.genfromtxt(StringIO(out), delimiter=",", usecols=(1, 2))
    return data

def rdann(record,annotator="atr"):
    """
    Reads annotations from a MIT record, using rdann
    """
    args = shlex.split("rdann -r "+record+" -a "+annotator)
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    annotations = [line.split() for line in StringIO(out)]
    return annotations

def wfdbdesc(record):
    """
    Get info from a MIT record, using wfdbdesc
    """
    args = shlex.split("wfdbdesc "+record)
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    info = {'channels':[]}

    for l in StringIO(out):
        if "Sampling frequency" in l:
            freq = (l.split(":")[1]).replace("Hz","")
            info['freq'] = int(freq)
        elif "Description" in l:
            chan = {'description': (l.split(":")[1]).strip()}
        elif "Gain" in l:
            chan['gain'] = int((l.split(" ")[2]).strip())
            info['channels'].append(chan)
    return info

def readBeatAnnotations(beatInfoFile):
    """
    Load annotations from a csv file: [sample, channel, type, label]
    """
    beatInfo = []
    if beatInfoFile != "":
        beatInfo = [line.strip().split(",") for line in open(beatInfoFile)]
    return beatInfo

def plotEcgPage(recordData, annotations, header, filter, samples, beatInfo, offset=0, pdf=None):
    """
    Plot a page of signal with annotations
    """
    pad = 3
    data = []
    for i in xrange(offset, offset + samples):
        data.extend(recordData[i])

    if len(data):
        dataMin = min(data);
        dataMax = max(data);
        yAxInit = dataMin - (dataMax - dataMin) / 4
        yAxEnd = dataMax + (dataMax - dataMin) / 3
        for i in range(channels):
            if pdf is not None:
                fig = plt.gcf()
                fig.set_size_inches(24+2*pad, 4 * channels)
            sp = plt.subplot(channels, 1, i + 1)
            sp.get_yaxis().set_visible(True)
            sp.get_xaxis().set_visible(False)
            sp.set_xlim(axInit, axEnd)
            sp.set_ylim(yAxInit, yAxEnd)
            sp.axis('off')
            if showGrid:
                plotGrid(yAxEnd,yAxInit)
            sp.plot(data[i::channels], linewidth=0.7, color="blue")
            plotAnnotations(annotations,header,filter,offset, i, data)
            if showBeatInfo:
                plotBeatAnnotations(beatInfo,offset, i, data)

        plt.tight_layout(pad=pad)
        # show plot
        if pdf is not None:
            fromStr =  str(timedelta(seconds=int(offset/header['freq'])))
            toStr = str(timedelta(seconds=int((offset + len(data) / channels)/header['freq'])))
            plt.suptitle('Record '+ recordName +' - ' + fromStr + " to " + toStr + "  [ 1 square = 0.04sec/0.1mV ]")
            fig.savefig(pdf, format='pdf', dpi=600)
            plt.close()
        else:
            plt.show()


def plotAnnotations(annotations, header,filter, offset, channel, data):
    """
    Plot beat marks
    """
    minSample = offset
    maxSample = offset + len(data) / channels
    top = max(data)
    bottom = min(data)
    bottom = bottom -(top-bottom)/3
    plt.text(15, top+0.5, header['channels'][channel]['description'], color='black',fontsize=14)
    for a in annotations:
        sampleNumber = int(a[1])
        cls = str(a[2])
        if (not filter or cls in filter) and sampleNumber > minSample:
            if sampleNumber < maxSample:
                plt.axvline(x=sampleNumber - offset, color='black', linestyle="dashed", lw=0.8, alpha=0.8) #linestyle="-",
                plt.text(sampleNumber - offset, top, " " + cls, color='black',fontsize=14)
                if showSamples:
                    plt.text(sampleNumber - offset + 5, bottom, str(sampleNumber), color='grey',fontsize=8)
            else:
                break

def plotBeatAnnotations(beatInfo, offset, channel, data):
    """
    Plot beat marks
    """
    minSample = offset
    maxSample= offset + len(data)/channels
    for a in beatInfo:
        sampleNumber = int(a[0])
        chan= a[1]
        if sampleNumber > minSample:
            if sampleNumber < maxSample:
                if chan=="*" or channel == int(chan):
                    type=a[2]
                    label = a[3]
                    plotBeatAnnotaion(plt, sampleNumber, type, offset, sampleVal=sampleValue(sampleNumber, channel), label=label)
            else:
                break;

def sampleValue(position, channel=0):
    return recordData[position][channel]


def plotBeatAnnotaion(plt, pos, type, offset, sampleVal, label=""):
    """
    Plot wave mark
    """
    color= "green" if label == "p" else 'orange' if label == "t" else "brown"
    textcolor = "black"
    if type == "^":
        x = pos - offset
        y0 = sampleVal - 0.2
        y1 = sampleVal + 0.2
        plt.plot([x,x],[y0,y1], linestyle='-', lw=1, color=color)
        plt.text(pos - offset - (10 if label == "r" else 2.5), sampleVal - 0.35 , label, fontsize=11, color=textcolor,alpha=0.9)
    else:
        symbol = type
        plt.text(pos - offset, sampleVal-0.05 , symbol, fontsize=19, color=color,alpha=1)


def plotGrid(top, bottom):
    """
    Plot grid
    """
    pageWidthInSeconds = (pageSize/freq)
    numberOfLines = pageWidthInSeconds*25
    for i in xrange(1,numberOfLines+1):
        pos = i*pageSize/numberOfLines
        plt.axvline(x=pos, color='red', lw=0.1, alpha=.3 if i%5==0 else 0.1)

    for i in xrange(int(bottom)-1,int(top+1)):
        for j in xrange(10):
            plt.axhline(y=i+float(j)/10, color='red', lw=0.1, alpha=.3 if j == 0 or j==5 else 0.1)

# Print iterations progress
def printProgress (iteration, total, prefix = '', suffix = '', decimals = 2, barLength = 100):
    filledLength    = int(round(barLength * iteration / float(total)))
    percents        = round(100.00 * (iteration / float(total)), decimals)
    bar             = '#' * filledLength + '-' * (barLength - filledLength)
    sys.stdout.write('%s [%s] %s%s %s\r' % (prefix, bar, percents, '%', suffix)),
    sys.stdout.flush()
    if iteration == total:
        print("\n")

"""
Main program
"""
parser = OptionParser()
parser.add_option("-r", "--record", dest="record", default="", help="Record to print")
parser.add_option("-a", "--annotator", dest="annotator", default="atr", help="Annotator")
parser.add_option("-o", "--offset", dest="offset", default="0", help="Offset to start printing in seconds or as an absolute instant in the format hh:mm:ss (default=0)")
parser.add_option("-l", "--limit", dest="limit", default="", help="Limit to print in seconds or as an absolute instant in the format hh:mm:ss (default=None)")
parser.add_option("-p", "--pageSize", dest="pageSize", default=10, help="Number of seconds per page (default=10)")
parser.add_option("-f", "--filter", dest="filter", default="", help="Filter beat classes shown Ex:N,V")
parser.add_option("-b", "--beatInfo", dest="beatInfo", default="", help="File with beat info (i.e. waves, peaks, ...)")
parser.add_option("-d", "--destination", dest="output", default="ecg.pdf", help="Output file")
parser.add_option("--showSamples", action="store_true", dest="showSamples", help="Show sample numbers")
parser.add_option("--showGrid", action="store_true", dest="showGrid", help="Show grid")

(options, args) = parser.parse_args()
filter= options.filter.split(",") if options.filter else []
showSamples = options.showSamples
showGrid = options.showGrid
beatInfoFile=options.beatInfo
showBeatInfo = True if beatInfoFile else False

# get record path from options
record = options.record

if not record:
    parser.print_help()
    sys.exit(1)

recordName = os.path.basename(record)
# read header info
header = wfdbdesc(record)

if not 'freq' in header.keys():
    print "Unable to find header file for record '" + recordName + "'"
    sys.exit(1)

# number of channels in the input file
channels = len(header["channels"])
freq = header["freq"]



# get record samples
# print "Record info: ", header
print "Loading data and annotations for record " + recordName + "..."
recordData = rdsamp(record)
annotations = rdann(record,options.annotator)
beatInfo = readBeatAnnotations(beatInfoFile) if showBeatInfo else []
beatInfo.sort(key=lambda x: int(x[0]))
gain = header["channels"][0]["gain"]
recordData = recordData / gain
totalSamples = len(recordData)
samplesPerLead = totalSamples

if ":" in options.offset:
    t = datetime.strptime(options.offset,"%H:%M:%S")
    secs = timedelta(hours=t.hour, minutes=t.minute, seconds=t.second).total_seconds()
    offset = int(secs*freq)
else:
    offset=int(options.offset)*freq

if not options.limit:
    limit = totalSamples
elif ":" in options.limit:
    t = datetime.strptime(options.limit,"%H:%M:%S")
    secs = timedelta(hours=t.hour, minutes=t.minute, seconds=t.second).total_seconds()
    limit = int(secs*freq-offset)
else:
    limit=int(options.limit)*freq

samples = min(samplesPerLead, offset + limit) if limit > 0 else samplesPerLead
pageSize = int(options.pageSize)*freq

start = offset
axEnd = pageSize
axInit = 0
pages = limit / pageSize
print "Read " + str(len(recordData)) + " samples"
print "Read " + str(len(annotations)) + " annotations"
print "Generating PDF (" + str(pages) + " pages) " + ( " [Use --limit to print only a record fragment]" if not options.limit else "...")



totalTime = 0
pdf = PdfPages(options.output)
# iterate and print pages
currentPage = 1
while start < samples:
    if start + pageSize > samples:
        pageSize = samples - start
    start_time = time.time()
    plotEcgPage(recordData, annotations, header, filter, pageSize,beatInfo,start, pdf)
    elapsed_time = time.time() - start_time
    totalTime += elapsed_time;
    remaining = timedelta(seconds= totalTime/currentPage * (pages-currentPage));
    formattedTd = str(remaining).split('.')[0]
    printProgress(currentPage, pages, prefix = 'Progress:', suffix = 'Complete. ' + formattedTd + " remaining.", barLength = 50)
    start = start + pageSize
    currentPage+=1
pdf.close()

print "Done. Check " + options.output
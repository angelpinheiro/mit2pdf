#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on Mon May 2 09:30:21 2016
Utility to generate an annotated PDF from a MIT record

Usage: ./mit2pdf [options]

@author: Ángel Piñeiro Souto
"""

from StringIO import StringIO
from optparse import OptionParser
from matplotlib.backends.backend_pdf import PdfPages
from datetime import datetime, timedelta
import time
import matplotlib.pyplot as plt
import numpy as np
import subprocess
import shlex
import json
import os, sys

QRS_ANNS = ['N', 'L','R','B','A','a','J','S','V','r','F','e','j','n','E','/','f','Q','?']

def rdsamp(record):
    """
    Reads data from a MIT record, using rdsamp
    """
    cmd = "rdsamp -r "+record+" -c"
    print "  Running $ " +  cmd + " ..."
    args = shlex.split(cmd)
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    data = np.genfromtxt(StringIO(out), delimiter=",", usecols=(1, 2))
    return data

def rdann(record,annotators=[], filter=[]):
    """
    Reads annotations from a MIT record, using rdann
    """
    annotations = []
    for annotator in annotators:
        #print "Reading annotations from " + annotator + " annotator..."
        cmd = "rdann -r "+record+" -a "+annotator
        if len(filter):
            cmd += " -p " + (" ".join(filter))

        print "  Running $ " +  cmd + " ..."
        args = shlex.split(cmd)
        p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate()
        anns = [line.split() for line in StringIO(out)]
        annotations.extend(anns)
    return annotations

def wfdbdesc(record):
    """
    Get info from a MIT record, using wfdbdesc
    """
    cmd = "wfdbdesc "+record
    print "  Running $ " +  cmd + " ..."
    args = shlex.split(cmd)
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    info = {'channels':[]}

    for l in StringIO(out):
        if "Sampling frequency" in l:
            freq = (l.split(":")[1]).replace("Hz","")
            info['freq'] = int(freq)
        elif "Description" in l:
            chan = {'description': (l.split(":")[1]).strip()}
        elif "Gain" in l:
            chan['gain'] = int((l.split(" ")[2]).strip())
            info['channels'].append(chan)
    return info

def readBeatAnnotations(beatInfoFile):
    """
    Load annotations from a csv file: [sample, channel, type, label]
    """
    beatInfo = []
    if beatInfoFile != "":
        beatInfo = [line.strip().split(",") for line in open(beatInfoFile)]
    return beatInfo

def sampleValue(position, channel=0):
    return recordData[position][channel]

def plotEcgPage(recordData, annotations, header, filter, samples, beatInfo, offset=0,lastDrawn=0, pdf=None):
    """
    Plot a page of signal with annotations
    """
    padding = 3
    data = []
    for i in xrange(offset, offset + samples):
        data.extend(recordData[i])

    if not len(data):
         return

    dataMin = min(data);
    dataMax = max(data);
    yAxInit = dataMin - (dataMax - dataMin) / 4
    yAxEnd = dataMax + (dataMax - dataMin) / 3
    for i in range(channels):
        if pdf is not None:
            fig = plt.gcf()
            fig.set_size_inches(float(options.pageSize)*2.4+2*padding, 4 * channels)
        sp = plt.subplot(channels, 1, i + 1)
        sp.get_yaxis().set_visible(True)
        sp.get_xaxis().set_visible(False)
        sp.set_xlim(axInit, axEnd)
        sp.set_ylim(yAxInit, yAxEnd)
        sp.axis('off')
        if showGrid:
            plotGrid(yAxEnd,yAxInit)
        sp.plot(data[i::channels], linewidth=0.7, color="blue")
        plotAnnotations(annotations,header,filter,offset, i, data, lastDrawn)

    plt.tight_layout(pad=padding)
    fromStr =  str(timedelta(seconds=int(offset/header['freq'])))
    toStr = str(timedelta(seconds=int((offset + len(data) / channels)/header['freq'])))
    plt.suptitle('Record '+ recordName +' - ' + fromStr + " to " + toStr + ("  [ 1 square = 0.04sec/0.1mV ]" if showGrid else ""))
    fig.savefig(pdf, format='pdf', dpi=600)
    plt.close()


def plotAnnotations(annotations, header,filter, offset, channel, data, lastDrawn):
    """
    Plot annotations
    """
    minSample = offset
    maxSample = offset + len(data) / channels
    top = max(data)
    bottom = min(data)
    bottom = bottom -(top-bottom)/3
    plt.text(15, top+0.5, header['channels'][channel]['description'], color='black',fontsize=14)
    for a in annotations[lastDrawn:len(annotations)]:
        annotation = {
            'sampleNumber': int(a[1]),
            'type': a[2],
            'channel': int(a[4]),
            'aux': a[6] if len(a) > 6 else ""
        }

        if (not filter or annotation['type'] in filter) and annotation['sampleNumber'] > minSample:
            if annotation['sampleNumber'] < maxSample :
                plotAnnotaion(annotation, offset, top, bottom, channel)
            else:
                break

        lastDrawn+=1


def plotAnnotaion(a, offset, top, bottom, channel):
    """
    Plot annotation
    """
    color = "green" if a['aux'] == "p" else "brown" if a["aux"] == "t" else "black"
    textcolor= "black"
    position = a["sampleNumber"]
    sampVal = sampleValue(position, channel)

    # beat annotations
    if a['type'] in QRS_ANNS:
        plt.axvline(x=position - offset, color='black', linestyle="dashed", lw=0.8, alpha=0.8)
        plt.text(position - offset, top, " " + a['type'], color='black',fontsize=14)
        plt.text(position - offset + 5, bottom, str(position), color='grey',fontsize=8)
    # wave start and end annotations
    elif a['type'] in [ "(", ")"] and a["channel"] == channel:
        x = position - offset
        x2 = x + (2 if a["type"] == "(" else -2)
        y0 = sampVal - 0.2
        y1 = sampVal + 0.2
        plt.plot([x,x],[y0,y1], linestyle='-', lw=1, color=color)
        plt.plot([x,x2],[y0,y0], linestyle='-', lw=1, color=color)
        plt.plot([x,x2],[y1,y1], linestyle='-', lw=1, color=color)
        if a["aux"] in ["q","s"]:
            plt.text(position - offset - (1000/freq) - (6 if a["aux"] == "q" else -6), sampVal-0.1  , a["aux"], fontsize=12, color=color, alpha=1)
    # p and t peaks
    elif a['type'] in [ 'p', 't'] and a["channel"] == channel :
        x = position - offset
        y0 = sampVal - 0.2
        y1 = sampVal + 0.2
        plt.plot([x,x],[y0,y1], linestyle='-', lw=1, color=color)
        plt.text(position - offset - (1000/freq) - 2, sampVal+0.3 ,a['type'], fontsize=12, color=textcolor,alpha=1)
    # r peak (aux = 'r')
    elif a["aux"] == "r" and a["channel"] == channel:
        plt.plot([position - offset], [sampVal], 'o', color=color, ms=1.5)
        plt.text(position - offset - (1000/freq)-5, sampVal , a["aux"], fontsize=11, color=color,alpha=1)

def plotGrid(top, bottom):
    """
    Plot grid
    """
    pageWidthInSeconds = (pageSize/freq)
    numberOfLines = pageWidthInSeconds*25
    for i in xrange(1,numberOfLines+1):
        pos = i*pageSize/numberOfLines
        plt.axvline(x=pos, color='red', lw=0.1, alpha=.3 if i%5==0 else 0.1)

    for i in xrange(int(bottom)-1,int(top+1)):
        for j in xrange(10):
            plt.axhline(y=i+float(j)/10, color='red', lw=0.1, alpha=.3 if j == 0 or j==5 else 0.1)

# Print iterations progress
def printProgress (iteration, total, prefix = '', suffix = '', decimals = 2, barLength = 100):
    filledLength    = int(round(barLength * iteration / float(total)))
    percents        = round(100.00 * (iteration / float(total)), decimals)
    bar             = '#' * filledLength + '-' * (barLength - filledLength)
    sys.stdout.write('%s [%s] %s%s %s\r' % (prefix, bar, percents, '%', suffix)),
    sys.stdout.flush()
    if iteration >= total:
        print("\n")

"""
Main program
"""
parser = OptionParser()
parser.add_option("-r", "--record", dest="record", default="", help="Record to print")
parser.add_option("-a", "--annotator", dest="annotator", default="atr", help="Annotator")
parser.add_option("-o", "--offset", dest="offset", default="0", help="Offset to start printing in seconds or as an absolute instant in the format hh:mm:ss (default=0)")
parser.add_option("-l", "--limit", dest="limit", default="", help="Limit to print in seconds or as an absolute instant in the format hh:mm:ss (default=None)")
parser.add_option("-p", "--pageSize", dest="pageSize", default=10, help="Number of seconds per page (default=10)")
parser.add_option("-f", "--filter", dest="filter", default="", help="Filter beat classes shown Ex:N,V")
parser.add_option("-b", "--beatInfo", dest="beatInfo", default="", help="File with beat info (i.e. waves, peaks, ...)")
parser.add_option("-d", "--destination", dest="output", default="ecg.pdf", help="Output file")
parser.add_option("--showSamples", action="store_true", dest="showSamples", help="Show sample numbers")
parser.add_option("--showGrid", action="store_true", dest="showGrid", help="Show grid")

(options, args) = parser.parse_args()
filter= options.filter.split(",") if options.filter else []
showSamples = options.showSamples
showGrid = options.showGrid
beatInfoFile=options.beatInfo
showBeatInfo = True if beatInfoFile else False

# get record path from options
record = options.record

if not record:
    parser.print_help()
    sys.exit(1)

recordName = os.path.basename(record)

print "Loading record " + recordName + "..."
# read header info
header = wfdbdesc(record)

if not 'freq' in header.keys():
    print "Unable to find header file for record '" + recordName + "'"
    sys.exit(1)

# number of channels in the input file
channels = len(header["channels"])
freq = header["freq"]

recordData = rdsamp(record)
annotators = options.annotator.split(",")
annotations = rdann(record,annotators,filter)
annotations.sort(key=lambda x: int(x[1]))

gain = header["channels"][0]["gain"]
recordData = recordData / gain
totalSamples = len(recordData)
samplesPerLead = totalSamples

if ":" in options.offset:
    t = datetime.strptime(options.offset,"%H:%M:%S")
    secs = timedelta(hours=t.hour, minutes=t.minute, seconds=t.second).total_seconds()
    offset = int(secs*freq)
else:
    offset=int(options.offset)*freq

if not options.limit:
    limit = totalSamples
elif ":" in options.limit:
    t = datetime.strptime(options.limit,"%H:%M:%S")
    secs = timedelta(hours=t.hour, minutes=t.minute, seconds=t.second).total_seconds()
    limit = int(secs*freq-offset)
else:
    limit=int(options.limit)*freq

samples = min(samplesPerLead, offset + limit) if limit > 0 else samplesPerLead
pageSize = int(options.pageSize)*freq

start = offset
axEnd = pageSize
axInit = 0
pages = limit / pageSize
print "Read " + str(len(recordData)) + " samples"
print "Read " + str(len(annotations)) + " annotations"
print "Generating PDF (" + str(pages) + " pages) " + ( " [Use --limit to print only a record fragment]" if not options.limit else "...")


totalTime = 0
lastDrawn=0
pdf = PdfPages(options.output)
# iterate and print pages
currentPage = 1
while start < samples:
    if start + pageSize > samples:
        pageSize = samples - start
    start_time = time.time()
    plotEcgPage(recordData, annotations, header, filter, pageSize,[],start, lastDrawn, pdf)
    elapsed_time = time.time() - start_time
    totalTime += elapsed_time;
    remaining = timedelta(seconds= totalTime/currentPage * (pages-currentPage));
    formattedTd = str(remaining).split('.')[0]
    printProgress(currentPage, pages, prefix = 'Progress:', suffix = 'Complete. ' + formattedTd + " remaining.", barLength = 50)
    start = start + pageSize
    currentPage+=1
pdf.close()

print "Done. Check " + options.output